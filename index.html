<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.29">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Matías Castillo-Aguilar">

<title>A Unified Probabilistic Framework for Non-Stationary Heart Rate Variability Analysis</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="index_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-0815c480559380816a4d1ea211a47e91.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-81267100e462c21b3d6c0d5bf76a3417.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="quarto-light">

<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">A Unified Probabilistic Framework for Non-Stationary Heart Rate Variability Analysis</h1>
            <p class="subtitle lead">Modeling the Dynamic Evolution of Autonomic Control</p>
          </div>

    
    <div class="quarto-title-meta-container">
      <div class="quarto-title-meta-column-start">
        
        <div class="quarto-title-meta">

                <div>
            <div class="quarto-title-meta-heading">Author</div>
            <div class="quarto-title-meta-contents">
                        <p>Matías Castillo-Aguilar <a href="mailto:m99castillo@gmail.com" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> <a href="https://orcid.org/0000-0001-7291-247X" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a></p>
                      </div>
          </div>
                
          
                <div>
            <div class="quarto-title-meta-heading">Modified</div>
            <div class="quarto-title-meta-contents">
              <p class="date-modified">September 3, 2025</p>
            </div>
          </div>
                
              </div>
      </div>
      <div class="quarto-title-meta-column-end quarto-other-formats-target">
      <div class="quarto-alternate-formats"><div class="quarto-title-meta-heading">Other Formats</div><div class="quarto-title-meta-contents"><p><a href="index.pdf"><i class="bi bi-file-pdf"></i>PDF</a></p></div></div></div>
    </div>



    <div class="quarto-other-links-text-target">
    </div>  </div>
</header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#methods" id="toc-methods" class="nav-link" data-scroll-target="#methods">Methods</a>
  <ul class="collapse">
  <li><a href="#model-formulation" id="toc-model-formulation" class="nav-link" data-scroll-target="#model-formulation">Model Formulation</a>
  <ul class="collapse">
  <li><a href="#baseline-heart-period-mathrmrrt_i" id="toc-baseline-heart-period-mathrmrrt_i" class="nav-link" data-scroll-target="#baseline-heart-period-mathrmrrt_i">Baseline Heart Period: <span class="math inline">\(\mathrm{RR}(t_i)\)</span></a></li>
  <li><a href="#generative-model-for-signal-variability" id="toc-generative-model-for-signal-variability" class="nav-link" data-scroll-target="#generative-model-for-signal-variability">Generative Model for Signal Variability</a></li>
  <li><a href="#spectral-components" id="toc-spectral-components" class="nav-link" data-scroll-target="#spectral-components">Spectral Components</a></li>
  <li><a href="#model-parameterization-and-priors" id="toc-model-parameterization-and-priors" class="nav-link" data-scroll-target="#model-parameterization-and-priors">Model Parameterization and Priors</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a></li>
  <li><a href="#discussion" id="toc-discussion" class="nav-link" data-scroll-target="#discussion">Discussion</a></li>
  </ul>
</nav>
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">



  


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>The rhythm of the human heart, far from being a simple, constant beat, is a complex and dynamic signal reflecting the continuous interplay between an organism and its internal and external environments. The precise timing between successive heartbeats, measured as the R-R interval (RRi), is a primary non-invasive proxy for autonomic nervous system (ANS) activity. The analysis of variations in this interval, a discipline known as heart rate variability (HRV), has become a cornerstone for assessing cardiovascular health, stress responses, and overall physiological state. This variability arises from the coordinated actions of multiple regulatory systems, including the sympathetic and parasympathetic branches of the ANS, baroreflexes, and thermoregulatory mechanisms.</p>
<p>Despite its utility, a significant limitation of traditional HRV analysis is its reliance on time-domain or frequency-domain metrics derived from static, short-term data windows. While such methods may offer insights into a snapshot of a physiological state under controlled conditions, they are fundamentally ill-suited to capture the dynamic, non-stationary nature of RRi signals during physiological transitions or stress, such as exercise, cognitive tasks, or pharmacologic interventions. The implicit assumption of stationarity in these fixed-window approaches can obscure subtle, yet physiologically critical, shifts in heart rate and its underlying variability. Furthermore, these conventional analyses often fail to establish a direct mechanistic link between observed changes in HRV and the underlying physiological processes responsible for them. For instance, a generalized decrease in HRV may be interpreted as a withdrawal of parasympathetic tone but could also stem from a complex shift in the balance of different frequency components of autonomic modulation. Disentangling these potential causes necessitates a more sophisticated, unified modeling paradigm.</p>
<p>Attempts to address these limitations have been made using a variety of modeling approaches, but these have often fallen short. For instance, state-space models have shown promise in tracking the evolution of cardiac dynamics, but their complexity can make parameter estimation difficult and their physiological interpretability limited. While time-frequency analysis methods, such as wavelets, can successfully visualize the time-varying nature of spectral content, they typically do not provide a generative model for testing specific physiological hypotheses. Moreover, they often lack a principled way to separate structured physiological variability from unstructured noise. Other efforts have focused on non-linear dynamics and fractal analysis, but these models are often phenomenological, describing the properties of the signal without offering a clear, mechanistic link to the underlying physiology. Consequently, no existing model provides a unified, probabilistic framework that can simultaneously capture and mechanistically interpret changes in both the mean RRi and its multi-component variability.</p>
<p>To advance the field beyond these constraints, a new generation of statistical models is clearly needed. These models must transcend simple descriptive statistics to provide a unified framework that simultaneously captures the time-varying nature of both the mean heart rate and the dynamic evolution of its multi-timescale variability. Such a framework should explicitly address the non-stationarity inherent to physiological signals, obviating the need for arbitrary, fixed-length analysis windows. It must be capable of decomposing the signal into its distinct components, separating the gross, underlying trends in heart rate from the structured, oscillatory variability that represents physiological regulation. Crucially, the model’s parameters should have a direct, interpretable link to specific physiological processes, such as autonomic tone, sympathetic-parasympathetic balance, and the dynamics of recovery. As a probabilistic framework, it should also provide a principled means of quantifying the uncertainty associated with all parameter estimates, moving beyond a reliance on point estimates to offer a more complete picture of the physiological state.</p>
<p>This paper presents a novel probabilistic framework for analyzing non-stationary RRi signals. Our approach directly confronts these challenges by formulating the RRi signal as a continuous stochastic process. This model decomposes the signal into a deterministic mean trajectory and a time-varying total standard deviation, both of which are constructed mechanistically. The model’s key innovations include a mechanistic model for the mean RRi that uses a flexible double-logistic function to allow for the direct estimation of physiologically salient parameters, such as the magnitude of heart rate change and the timing of response and recovery. A core innovation is the explicit decomposition of the total signal variance into components representing structured, oscillatory variability and unstructured, residual noise, which is critical for understanding the sources of change in HRV. We generalize the traditional SDNN metric into a time-varying trajectory, which is also modeled using a logistic function analogous to that for the mean RRi, thereby capturing the dynamic suppression and recovery of total variability in a parsimonious manner. A crucial mathematical inversion within the framework ensures that the amplitude of the synthesized structured signal exactly matches the target SDNN trajectory at every time point, effectively decoupling the total magnitude of variability from its spectral composition and enabling more granular analysis. Finally, the model captures the dynamic allocation of power across different physiological frequency bands by modeling their proportions as a function of a smooth master controller, which allows for a detailed analysis of shifts in spectral balance during physiological transitions.</p>
<p>The primary objective of this study is to introduce and validate this novel probabilistic model for the analysis of non-stationary RRi signals. We aim to demonstrate that this framework provides a more robust, informative, and physiologically interpretable analysis of heart rate dynamics than traditional methods. We hypothesize that the model will accurately and robustly capture the complex, time-varying dynamics of both the mean RRi and its variability during transient physiological perturbations. We further propose that the model’s parameters will yield enhanced mechanistic insights into autonomic control and cardiovascular regulation, thereby serving as a superior tool for both clinical research and basic physiological investigation. Through this work, we seek to establish a new standard for the analysis of time-varying physiological signals.</p>
</section>
<section id="methods" class="level1">
<h1>Methods</h1>
<section id="model-formulation" class="level2">
<h2 class="anchored" data-anchor-id="model-formulation">Model Formulation</h2>
<p>We model the R–R interval (RRi) signal, observed at a discrete set of time points <span class="math inline">\(\{t_i\}_{i=1}^N\)</span>, as a probabilistic process. The model’s central thesis is that the signal can be generated from two fundamental, time-varying trajectories: a deterministic mean, <span class="math inline">\(\mu(t_i)\)</span>, and a total standard deviation, <span class="math inline">\(\mathrm{SDNN}(t_i)\)</span>. This approach provides a principled framework for understanding the interplay between underlying physiological trends and the dynamics of heart rate variability. The complete observation model is defined by the Normal likelihood in <a href="#eq-full-likelihood" class="quarto-xref">Equation&nbsp;1</a>.</p>
<p><span id="eq-full-likelihood"><span class="math display">\[
\mathrm{RRi}(t_i) \sim \mathcal{N}\big(\mu(t_i), \mathrm{SDNN}(t_i)\big)
\tag{1}\]</span></span></p>
<p>The core of the model lies in the detailed, mechanistic construction of these two components from a shared set of underlying dynamic functions. The mean trajectory, <span class="math inline">\(\mu(t_i)\)</span>, is a superposition of a smoothly varying baseline trend and a synthesized, structured noise signal, as shown in <a href="#eq-mean-model" class="quarto-xref">Equation&nbsp;2</a>.</p>
<p><span id="eq-mean-model"><span class="math display">\[
\mu(t_i)
= \underbrace{\mathrm{RR}(t_i)}_{\substack{\text{Gross}\\\text{RRi Trend}}}
+
\underbrace{A(t_i) \cdot \sum_{j=1}^{J} p_j(t_i) \cdot S_j(t_i)}_{\substack{\text{Unit-Variance Structured Noise}}}
\tag{2}\]</span></span></p>
<p>Here, <span class="math inline">\(\mathrm{RR}(t_i)\)</span> represents the gross, underlying heart period trajectory. The structured noise component is synthesized from a set of spectral oscillators, <span class="math inline">\(S_j(t_i)\)</span>, which represent activity in different physiological frequency bands (<span class="math inline">\(j=1,2,3\)</span> for VLF, LF, and HF, respectively). These oscillators are weighted by time-varying proportions, <span class="math inline">\(p_j(t_i)\)</span>. Their combined magnitude is governed by an internal amplitude normalization factor, <span class="math inline">\(A(t_i)\)</span>, which ensures this entire structured component has a standard deviation of exactly one at all times.</p>
<p>The model’s second primary output, the <span class="math inline">\(\mathrm{SDNN}(t_i)\)</span> trajectory, represents the total instantaneous standard deviation of the RRi signal. By directly modeling this quantity and supplying it to the likelihood, the framework parsimoniously captures the complete time-dependent evolution of heart rate variability without needing to estimate a separate residual error term. This formulation facilitates a unified analysis that simultaneously captures phenomena in both the time and frequency domains, obviating the need for traditional sliding-window decompositions.</p>
<section id="baseline-heart-period-mathrmrrt_i" class="level3">
<h3 class="anchored" data-anchor-id="baseline-heart-period-mathrmrrt_i">Baseline Heart Period: <span class="math inline">\(\mathrm{RR}(t_i)\)</span></h3>
<p>The <span class="math inline">\(\mathrm{RR}(t_i)\)</span> component quantifies the gross, underlying variations in the mean R–R interval. These fluctuations arise from short-term physiological regulatory processes, including changes in metabolic and cardiovascular demand and shifts in tonic autonomic drive. To capture these dynamics, this component is parameterized using a flexible double-logistic function, which yields interpretable “onset” and “recovery” parameters. This function, shown in <a href="#eq-rri-baseline-model" class="quarto-xref">Equation&nbsp;3</a>, is particularly well-suited for modeling physiological responses to a transient perturbation like exercise.</p>
<p><span id="eq-rri-baseline-model"><span class="math display">\[
\mathrm{RR}(t_i) =
\underbrace{\alpha_r}_{\substack{\text{Resting RRi}}}
-
\underbrace{\beta_r \cdot \mathcal{D}_{1}(t_i)}_{\substack{\text{Perturbation-induced}\\\text{RRi Drop}}}
+
\underbrace{c_r \beta_r \cdot \mathcal{D}_{2}(t_i)}_{\substack{\text{Post-perturbation}\\\text{RRi Recovery}}}
\tag{3}\]</span></span></p>
<p>In this formulation, <span class="math inline">\(\alpha_r\)</span> represents the initial, stable heart period, interpretable as the baseline vagal tone. The parameter <span class="math inline">\(\beta_r\)</span> signifies the magnitude of the decline in RRi induced by the perturbation. The fractional recovery amplitude is denoted by <span class="math inline">\(c_r\)</span>, where <span class="math inline">\(c_r \in [0, 1)\)</span> indicates a partial recovery and <span class="math inline">\(c_r &gt; 1\)</span> indicates an overshoot. The dynamics are driven by two logistic transition functions, <span class="math inline">\(\mathcal{D}_{1}(t_i)\)</span> and <span class="math inline">\(\mathcal{D}_{2}(t_i)\)</span>, defined in <a href="#eq-logistic-components" class="quarto-xref">Equation&nbsp;4</a>.</p>
<p><span id="eq-logistic-components"><span class="math display">\[
\begin{aligned}
\mathcal{D}_{1}(t_i) &amp;= \left(1+ e^{-\lambda (t_i - \tau)}\right)^{-1} \\
\mathcal{D}_{2}(t_i) &amp;= \left(1+ e^{-\phi (t_i - \tau - \delta)}\right)^{-1}
\end{aligned}
\tag{4}\]</span></span></p>
<p>The shared timing parameters govern these transitions: <span class="math inline">\(\tau\)</span> is the inflection point (midpoint) of the initial decline, whose rate is controlled by <span class="math inline">\(\lambda\)</span>. The second transition is offset from the first by a delay <span class="math inline">\(\delta\)</span>. This delay is dynamically constrained to ensure the recovery point <span class="math inline">\(\tau+\delta\)</span> occurs within the observation window. The recovery rate is governed by <span class="math inline">\(\phi\)</span>. This specific formulation directly estimates physiologically salient time points and magnitudes, facilitating enhanced mechanistic interpretation and improved comparability across different experimental conditions.</p>
</section>
<section id="generative-model-for-signal-variability" class="level3">
<h3 class="anchored" data-anchor-id="generative-model-for-signal-variability">Generative Model for Signal Variability</h3>
<p>A key innovation of this framework is its generative approach to signal variability. Instead of treating variability as a residual property, the model explicitly defines and constructs the dynamic trajectory of the signal’s total standard deviation.</p>
<section id="total-instantaneous-variability-mathrmsdnnt_i" class="level4">
<h4 class="anchored" data-anchor-id="total-instantaneous-variability-mathrmsdnnt_i">Total Instantaneous Variability: <span class="math inline">\(\mathrm{SDNN}(t_i)\)</span></h4>
<p>We generalize the conventional, static notion of SDNN (the standard deviation of normal-to-normal intervals) to a dynamic quantity, <span class="math inline">\(\mathrm{SDNN}(t_i)\)</span>. In this framework, <span class="math inline">\(\mathrm{SDNN}(t_i)\)</span> represents the total instantaneous standard deviation of the RRi signal. It is the parameter that governs the dispersion of the Normal likelihood at each time point. By modeling this trajectory directly, we can capture how the overall “strength” of autonomic modulation and other sources of variability evolves over time. To maintain parsimony and enforce a strong theoretical link between changes in mean and variability, the <span class="math inline">\(\mathrm{SDNN}(t_i)\)</span> trajectory is modeled using the same double-logistic functional form as the baseline RRi, as defined in <a href="#eq-sdnn-model" class="quarto-xref">Equation&nbsp;5</a>.</p>
<p><span id="eq-sdnn-model"><span class="math display">\[
\mathrm{SDNN}(t_i) =
\underbrace{\alpha_s}_{\substack{\text{Resting SDNN}}}
-
\underbrace{\beta_s \cdot \mathcal{D}_{1}(t_i)}_{\substack{\text{Perturbation-induced}\\\text{SDNN Drop}}}
+
\underbrace{c_s \beta_s \cdot \mathcal{D}_{2}(t_i)}_{\substack{\text{Post-perturbation}\\\text{SDNN Recovery}}}
\tag{5}\]</span></span></p>
<p>Here, <span class="math inline">\(\alpha_s\)</span>, <span class="math inline">\(\beta_s\)</span>, and <span class="math inline">\(c_s\)</span> are analogous to their counterparts in the baseline model, representing the resting total SDNN, the magnitude of its suppression, and its fractional recovery, respectively. This trajectory shares the same timing parameters (<span class="math inline">\(\tau, \delta, \lambda, \phi\)</span>) as the mean RRi, enforcing the strong physiological assumption that changes in the magnitude of variability are temporally coupled with changes in the mean heart period.</p>
</section>
<section id="internal-amplitude-normalization-at_i" class="level4">
<h4 class="anchored" data-anchor-id="internal-amplitude-normalization-at_i">Internal Amplitude Normalization: <span class="math inline">\(A(t_i)\)</span></h4>
<p>The model must synthesize a structured noise signal, let’s call it <span class="math inline">\(X(t_i) = A(t_i) \sum_{j=1}^J p_j(t_i) S_j(t_i)\)</span>, which contributes to the mean trajectory <span class="math inline">\(\mu(t_i)\)</span>. A critical design choice is to separate the modeling of this signal’s spectral shape from the modeling of its overall magnitude. The magnitude is governed entirely by the <code>SDNN(t)</code> trajectory. Therefore, we require the synthesized signal <span class="math inline">\(X(t_i)\)</span> to be normalized such that its variance is precisely equal to one at every time point. This requires a deterministic calculation for the internal scaling amplitude, <span class="math inline">\(A(t_i)\)</span>.</p>
<p>By construction, the spectral oscillator signals <span class="math inline">\(S_j(t_i)\)</span> are standardized to have zero mean and unit variance (<span class="math inline">\(\mathrm{Var}[S_j(t_i)] = 1\)</span>). Assuming they are approximately uncorrelated, the variance of their weighted sum is:</p>
<p><span class="math display">\[
\mathrm{Var}\left[\sum_{j=1}^J p_j(t_i) S_j(t_i)\right] \approx \sum_{j=1}^J p_j(t_i)^2 \mathrm{Var}[S_j(t_i)] = \sum_{j=1}^J p_j(t_i)^2
\]</span></p>
<p>The variance of the complete structured noise signal is then <span class="math inline">\(\mathrm{Var}[X(t_i)] = A(t_i)^2 \sum_{j=1}^J p_j(t_i)^2\)</span>. To achieve our goal of unit variance, we set <span class="math inline">\(\mathrm{Var}[X(t_i)] = 1\)</span> and solve for <span class="math inline">\(A(t_i)\)</span>, which yields the critical normalization formula in <a href="#eq-amplitude-inversion" class="quarto-xref">Equation&nbsp;6</a>.</p>
<p><span id="eq-amplitude-inversion"><span class="math display">\[
A(t_i) = \frac{1}{\sqrt{\sum_{j=1}^J p_j(t_i)^2}}
\tag{6}\]</span></span></p>
<p>This normalization is essential. It ensures that the component representing structured noise in <a href="#eq-mean-model" class="quarto-xref">Equation&nbsp;2</a> is a pure, unit-variance process whose spectral character is determined by <span class="math inline">\(p_j(t_i)\)</span> but whose amplitude is fixed. The full, time-varying magnitude of variability is then introduced independently via the <span class="math inline">\(\mathrm{SDNN}(t_i)\)</span> term in the final likelihood (<a href="#eq-full-likelihood" class="quarto-xref">Equation&nbsp;1</a>). This elegant separation allows the model to learn how the spectral composition of HRV changes, independent of simultaneous changes in its total power.</p>
</section>
</section>
<section id="spectral-components" class="level3">
<h3 class="anchored" data-anchor-id="spectral-components">Spectral Components</h3>
<p>The spectral character of the structured noise is determined by the properties of the oscillator signals <span class="math inline">\(S_j(t_i)\)</span> and their time-varying weights <span class="math inline">\(p_j(t_i)\)</span>.</p>
<section id="dynamic-frequency-band-proportions" class="level4">
<h4 class="anchored" data-anchor-id="dynamic-frequency-band-proportions">Dynamic Frequency Band Proportions</h4>
<p>The proportions <span class="math inline">\(p_j(t_i)\)</span> dictate how the unit variance of the structured noise is allocated across the different frequency bands at each moment. The model captures the evolution of these proportions as a smooth transition between two distinct spectral states: a baseline state (<span class="math inline">\(\vec\pi_{\text{base}}\)</span>) and a perturbed state (<span class="math inline">\(\vec\pi_{\text{pert}}\)</span>). The transition is orchestrated by a single master controller function, <span class="math inline">\(C(t_i)\)</span>, as shown in the convex combination of <a href="#eq-pj-using-ct" class="quarto-xref">Equation&nbsp;7</a>.</p>
<p><span id="eq-pj-using-ct"><span class="math display">\[
\vec{p}(t_i) = (1 - C(t_i)) \cdot \vec\pi_{\text{base}} + C(t_i) \cdot \vec\pi_{\text{pert}}
\tag{7}\]</span></span></p>
<p>Here, <span class="math inline">\(\vec\pi_{\text{base}}\)</span> and <span class="math inline">\(\vec\pi_{\text{pert}}\)</span> are simplex vectors (their elements are non-negative and sum to one) that represent the characteristic spectral distributions at rest and during peak perturbation, respectively. To ensure efficient sampling, these vectors are not estimated directly but are constructed by transforming unconstrained real-valued parameters using the additive log-ratio (ALR) transformation, which is detailed in the parameterization section below. The master controller, <span class="math inline">\(C(t_i)\)</span>, is itself built from the same logistic building blocks, as defined in <a href="#eq-master-controller" class="quarto-xref">Equation&nbsp;8</a>.</p>
<p><span id="eq-master-controller"><span class="math display">\[
C(t_i) = \mathcal{D}_{1}(t_i) \cdot \left(1 - c_c \cdot \mathcal{D}_{2}(t_i)\right)
\tag{8}\]</span></span></p>
<p>This function naturally transitions from 0 (at baseline) towards 1 (during perturbation). The parameter <span class="math inline">\(c_c\)</span> allows for an incomplete spectral recovery, mirroring the flexibility of the mean and SDNN trajectories.</p>
</section>
<section id="multi-sine-spectral-oscillators" class="level4">
<h4 class="anchored" data-anchor-id="multi-sine-spectral-oscillators">Multi-Sine Spectral Oscillators</h4>
<p>To create a realistic spectral texture, each oscillator <span class="math inline">\(S_j(t_i)\)</span> is constructed as a superposition of <span class="math inline">\(K_j\)</span> distinct sinusoids within its designated frequency band. The un-normalized signal for band <span class="math inline">\(j\)</span>, denoted <span class="math inline">\(S'_j(t_i)\)</span>, is given by <a href="#eq-multi-sine-fun" class="quarto-xref">Equation&nbsp;9</a>.</p>
<p><span id="eq-multi-sine-fun"><span class="math display">\[
S'_j(t_i) = \sum_{k=1}^{K_j} a_{j,k} \sin(2 \pi f_{j,k} t_i + \phi_{j,k})
\tag{9}\]</span></span></p>
<p>The frequencies <span class="math inline">\(f_{j,k}\)</span> (in Hz) and phases <span class="math inline">\(\phi_{j,k}\)</span> are pre-specified. The amplitudes, <span class="math inline">\(a_{j,k}\)</span>, follow a power-law relationship with frequency, <span class="math inline">\(a_{j,k} \propto f_{j,k}^{-b/2}\)</span>, where <span class="math inline">\(b\)</span> is a shared spectral exponent. Finally, each composite signal <span class="math inline">\(S'_j(t_i)\)</span> undergoes empirical standardization to produce the final normalized oscillator signal, <span class="math inline">\(S_j(t_i)\)</span>, with mean zero and unit variance.</p>
</section>
</section>
<section id="model-parameterization-and-priors" class="level3">
<h3 class="anchored" data-anchor-id="model-parameterization-and-priors">Model Parameterization and Priors</h3>
<p>To ensure numerical stability and efficient sampling, all model parameters are estimated on an unconstrained real-valued scale (<span class="math inline">\(\mathbb{R}\)</span>). Priors are placed on these unconstrained parameters, which are then transformed back to their constrained, physically meaningful scales within the model. This section details these transformations.</p>
<section id="timing-rate-and-recovery-parameters" class="level4">
<h4 class="anchored" data-anchor-id="timing-rate-and-recovery-parameters">Timing, Rate, and Recovery Parameters</h4>
<p>Parameters constrained to a specific interval, such as probabilities or proportions of a range, are parameterized on the logit scale, while parameters constrained to be positive are parameterized on the log scale. For the timing parameters, the onset time <span class="math inline">\(\tau\)</span> is mapped to the observed time interval <span class="math inline">\([t_{\text{min}}, t_{\text{max}}]\)</span>, and the subsequent delay <span class="math inline">\(\delta\)</span> is mapped to the remaining time <span class="math inline">\([0, t_{\text{max}} - \tau]\)</span>.</p>
<p><span class="math display">\[
\tau = \text{inv\_logit}(\tau_{\text{logit}}) \cdot (t_{\text{max}} - t_{\text{min}}) + t_{\text{min}} \\
\delta = \text{inv\_logit}(\delta_{\text{logit}}) \cdot (t_{\text{max}} - \tau)
\]</span></p>
<p>Similarly, the positive rate parameters <span class="math inline">\(\lambda\)</span> and <span class="math inline">\(\phi\)</span> are log-transformed to allow them to be estimated on an unconstrained scale.</p>
<p><span class="math display">\[
\lambda = \exp(\lambda_{\text{log}}) \quad ; \quad \phi = \exp(\phi_{\text{log}})
\]</span></p>
<p>Finally, the recovery coefficients for RR, SDNN, and the master controller (<span class="math inline">\(c_r, c_s, c_c\)</span>) are mapped via a scaled logit transformation to the intervals <span class="math inline">\([0, 2]\)</span> and <span class="math inline">\([0, 1]\)</span>, respectively.</p>
<p><span class="math display">\[
c_r = \text{inv\_logit}(c_{r, \text{logit}}) \cdot 2 \quad ; \quad c_s = \text{inv\_logit}(c_{s, \text{logit}}) \cdot 2 \quad ; \quad c_c = \text{inv\_logit}(c_{c, \text{logit}})
\]</span></p>
</section>
<section id="magnitude-parameters-alpha-beta" class="level4">
<h4 class="anchored" data-anchor-id="magnitude-parameters-alpha-beta">Magnitude Parameters (<span class="math inline">\(\alpha, \beta\)</span>)</h4>
<p>The baseline and drop magnitudes are scaled relative to data-derived quantities to create dimensionless parameters whose priors are easier to specify and interpret. The RR magnitudes, <span class="math inline">\(\alpha_r\)</span> and <span class="math inline">\(\beta_r\)</span>, are parameterized relative to the observed range of the data and the estimated baseline, respectively.</p>
<p><span class="math display">\[
\alpha_r = \text{inv\_logit}(\alpha_{r, \text{logit}}) \cdot 2 \cdot \text{rr\_range} + \text{rr\_min} \\
\beta_r = \text{inv\_logit}(\beta_{r, \text{logit}}) \cdot \alpha_r
\]</span></p>
<p>In the same manner, the SDNN magnitudes, <span class="math inline">\(\alpha_s\)</span> and <span class="math inline">\(\beta_s\)</span>, are parameterized relative to the overall standard deviation of the data and the estimated baseline variability.</p>
<p><span class="math display">\[
\alpha_s = \text{inv\_logit}(\alpha_{s, \text{logit}}) \cdot \text{rr\_sd} \\
\beta_s = \text{inv\_logit}(\beta_{s, \text{logit}}) \cdot \alpha_s
\]</span></p>
</section>
<section id="spectral-proportion-parameters-alr-transformation" class="level4">
<h4 class="anchored" data-anchor-id="spectral-proportion-parameters-alr-transformation">Spectral Proportion Parameters (ALR Transformation)</h4>
<p>Directly placing a prior on a simplex (a vector of positive numbers that sum to one) can be inefficient for sampling. We use the additive log-ratio (ALR) transformation to map the 3-dimensional simplex vectors <span class="math inline">\(\vec\pi\)</span> to 2-dimensional unconstrained real vectors <span class="math inline">\(\vec{y} = [y_1, y_2]\)</span>. Choosing the third component as the reference, the transformation is:</p>
<p><span class="math display">\[
y_1 = \log\left(\frac{\pi_1}{\pi_3}\right) \quad ; \quad y_2 = \log\left(\frac{\pi_2}{\pi_3}\right)
\]</span></p>
<p>The model estimates the unconstrained vectors <span class="math inline">\(\vec{y}_{\text{base, log}}\)</span> and <span class="math inline">\(\vec{y}_{\text{pert, log}}\)</span>. These are mapped back to the simplex scale using the inverse transformation:</p>
<p><span class="math display">\[
\pi_1 = \frac{e^{y_1}}{1 + e^{y_1} + e^{y_2}} \quad ; \quad \pi_2 = \frac{e^{y_2}}{1 + e^{y_1} + e^{y_2}} \quad ; \quad \pi_3 = \frac{1}{1 + e^{y_1} + e^{y_2}}
\]</span></p>
<p>Weakly informative Normal priors are placed on the unconstrained logit, log, and ALR-transformed parameters, chosen to reflect plausible physiological assumptions (e.g., centering the spectral exponent <span class="math inline">\(b\)</span> around 1 for pink noise).</p>
</section>
</section>
</section>
</section>
<section id="results" class="level1">
<h1>Results</h1>
<p>[…].</p>
</section>
<section id="discussion" class="level1">
<h1>Discussion</h1>
<p>[…].</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>